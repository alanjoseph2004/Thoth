import socket
import threading
import time
import subprocess

# Constants
BROADCAST_PORT = 9999
BROADCAST_MESSAGE = "DISCOVER_THOTH"
NODE_TIMEOUT = 10  # Seconds to consider a node as active

# Global storage for discovered nodes
discovered_nodes = {}

# Function to interact with B.A.T.M.A.N.-adv and retrieve neighbors
def get_batman_neighbors():
    try:
        result = subprocess.run(["batctl", "n"], capture_output=True, text=True)
        neighbors = []
        for line in result.stdout.splitlines():
            parts = line.split()
            if len(parts) > 1:
                neighbors.append(parts[1])  # Extract neighbor IP or MAC
        return neighbors
    except Exception as e:
        print(f"[Error] Could not retrieve B.A.T.M.A.N. neighbors: {e}")
        return []

# Function to broadcast discovery messages on the LAN
def broadcast_lan_discovery():
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
        while True:
            sock.sendto(BROADCAST_MESSAGE.encode(), ('<broadcast>', BROADCAST_PORT))
            print("[LAN Discovery] Broadcast message sent.")
            time.sleep(5)  # Broadcast every 5 seconds

# Function to listen for LAN discovery messages
def listen_for_lan_discovery():
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        sock.bind(('', BROADCAST_PORT))
        while True:
            data, addr = sock.recvfrom(1024)
            if data.decode() == BROADCAST_MESSAGE:
                discovered_nodes[addr[0]] = time.time()
                print(f"[LAN Discovery] Discovered node: {addr[0]}.")

# Function to broadcast Off-LAN discovery using B.A.T.M.A.N.-adv
def broadcast_offlan_discovery():
    while True:
        neighbors = get_batman_neighbors()
        for neighbor in neighbors:
            send_message(neighbor, BROADCAST_MESSAGE)
        print("[Off-LAN Discovery] Broadcast message sent to mesh neighbors.")
        time.sleep(5)

# Function to handle incoming Off-LAN messages
def listen_for_offlan_discovery():
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
        sock.bind(("", BROADCAST_PORT))
        sock.listen(5)
        while True:
            conn, addr = sock.accept()
            data = conn.recv(1024).decode()
            if data == BROADCAST_MESSAGE:
                discovered_nodes[addr[0]] = time.time()
                print(f"[Off-LAN Discovery] Discovered node: {addr[0]}.")
            conn.close()

# Function to send a message to a specific IP
def send_message(ip, message):
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
        try:
            sock.connect((ip, BROADCAST_PORT))
            sock.sendall(message.encode())
            print(f"[Send] Message sent to {ip}: {message}")
        except Exception as e:
            print(f"[Error] Could not send message to {ip}: {e}")

# Function to clean up inactive nodes
def cleanup_nodes():
    while True:
        current_time = time.time()
        for node, last_seen in list(discovered_nodes.items()):
            if current_time - last_seen > NODE_TIMEOUT:
                print(f"[Cleanup] Node {node} timed out.")
                del discovered_nodes[node]
        time.sleep(5)

# Main function to start discovery threads
def main():
    # Start LAN discovery threads
    threading.Thread(target=broadcast_lan_discovery, daemon=True).start()
    threading.Thread(target=listen_for_lan_discovery, daemon=True).start()

    # Start Off-LAN discovery threads
    threading.Thread(target=broadcast_offlan_discovery, daemon=True).start()
    threading.Thread(target=listen_for_offlan_discovery, daemon=True).start()

    # Start cleanup thread
    threading.Thread(target=cleanup_nodes, daemon=True).start()

    print("[System] Node discovery started.")
    while True:
        print(f"[System] Active nodes: {list(discovered_nodes.keys())}")
        time.sleep(10)

if __name__ == "__main__":
    main()

